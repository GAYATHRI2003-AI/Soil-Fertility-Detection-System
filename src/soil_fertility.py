# -*- coding: utf-8 -*-
"""Soil_Fertility.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hPMUMxlZz8wfSRgH8hS4Ew4tZd719uK4
"""

import pandas as pd
import numpy as np
import random
import os
from datetime import datetime, timedelta
import matplotlib
matplotlib.use('Agg')  # Non-interactive backend
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from difflib import SequenceMatcher
import json

# 1. Setup specific Start and End dates (5 Days)
start_date = datetime(2026, 1, 1, 0, 0) # Jan 1st, Midnight
end_date = start_date + timedelta(days=5)
interval = timedelta(hours=1) # One reading every hour

timestamps = []
current_time = start_date
while current_time < end_date:
    timestamps.append(current_time)
    current_time += interval

def generate_sensor_data():
    # Slightly tighter ranges for more "realistic" synthetic data
    N = random.randint(15, 55)
    P = random.randint(10, 45)
    K = random.randint(20, 65)
    pH = round(random.uniform(5.8, 7.8), 2)
    moisture = random.randint(25, 80)
    return N, P, K, pH, moisture

def is_fertile(N, P, K, pH, moisture):
    # Logic: All parameters must be in ideal range
    if (20 <= N <= 50 and
        15 <= P <= 40 and
        30 <= K <= 60 and
        6.0 <= pH <= 7.5 and
        30 <= moisture <= 70):
        return 1
    return 0

# ============================================
# RAG KNOWLEDGE BASE FOR SOIL FERTILITY
# ============================================
SOIL_KNOWLEDGE_BASE = {
    "nitrogen": [
        "Nitrogen (N) is essential for plant leaf and stem growth. Optimal range: 20-50 mg/kg.",
        "Low nitrogen symptoms: stunted growth, pale yellow leaves, poor development.",
        "High nitrogen causes: excessive leaf growth, reduced fruiting, pest susceptibility.",
        "Nitrogen-rich sources: compost, manure, legume crops, ammonia fertilizers.",
        "NPK ratio 10:10:10 is standard balanced fertilizer for general crops.",
    ],
    "phosphorus": [
        "Phosphorus (P) is crucial for root development and energy transfer. Optimal: 15-40 mg/kg.",
        "Low phosphorus symptoms: weak root systems, delayed maturity, reddish discoloration.",
        "High phosphorus leads to: reduced micronutrient availability, potential runoff pollution.",
        "Phosphorus sources: bone meal, rock phosphate, superphosphate fertilizers.",
        "Phosphorus helps in flower and fruit development, essential for seed formation.",
    ],
    "potassium": [
        "Potassium (K) enhances plant vigor and disease resistance. Optimal: 30-60 mg/kg.",
        "Low potassium symptoms: weak stems, poor fruit quality, increased disease susceptibility.",
        "High potassium rarely causes problems but can interfere with Mg and Ca uptake.",
        "Potassium sources: potash, muriate of potash, wood ash, compost.",
        "Potassium improves drought tolerance and stress resistance in plants.",
    ],
    "ph": [
        "Soil pH affects nutrient availability. Optimal for most crops: 6.0-7.5 (slightly acidic to neutral).",
        "pH < 6.0 (acidic soil): Add lime (CaCO3) to raise pH, benefits acid-loving plants.",
        "pH > 7.5 (alkaline soil): Add sulfur or aluminum sulfate to lower pH.",
        "Very low pH (< 5.5) causes aluminum toxicity and nutrient deficiencies.",
        "Very high pH (> 8.0) locks up iron, zinc, and manganese, causing chlorosis.",
    ],
    "moisture": [
        "Soil moisture optimal range: 30-70% water holding capacity.",
        "Low moisture (< 30%): Causes drought stress, wilting, reduced nutrient uptake.",
        "High moisture (> 70%): Causes waterlogging, root rot, anaerobic conditions.",
        "Ideal moisture allows root penetration and nutrient availability.",
        "Add mulch to retain moisture in dry conditions, improve drainage in wet soils.",
    ],
    "soil_fertility": [
        "Fertile soil contains: adequate NPK, balanced pH, good moisture, 3%+ organic matter.",
        "Rich soil has excellent microbial activity, good soil structure, and drainage.",
        "Organic matter improves water retention, nutrient cycling, and microbial diversity.",
        "Soil testing every 2-3 years helps track fertility changes and guide amendments.",
        "Crop rotation and composting are sustainable ways to maintain soil fertility.",
    ],
    "recommendations": [
        "If nitrogen is low: Apply compost, aged manure, or nitrogen fertilizers (urea, ammonium nitrate).",
        "If phosphorus is low: Use bone meal, rock phosphate, or phosphate fertilizers.",
        "If potassium is low: Apply wood ash, potash, or potassium chloride fertilizers.",
        "For acidic soils (pH < 6): Add agricultural lime at 2-5 tons per hectare.",
        "For alkaline soils (pH > 7.5): Add sulfur or aluminum sulfate at 1-2 tons per hectare.",
        "If moisture is low: Increase mulching, reduce tillage, improve drainage with organic matter.",
        "If moisture is high: Improve drainage with gravel, create raised beds, reduce irrigation.",
        "Balanced NPK ratio of 10:10:10 suits most general crops; adjust based on crop type.",
    ]
}

class SoilFertilityRAG:
    """Simple RAG system for soil fertility recommendations without API keys"""
    
    def __init__(self, knowledge_base):
        self.knowledge_base = knowledge_base
    
    def retrieve_relevant_knowledge(self, parameter, value, optimal_range):
        """Retrieve relevant knowledge based on soil parameter"""
        relevant_docs = []
        
        # Determine if parameter is out of range
        if value < optimal_range[0]:
            status = "low"
            category = parameter.lower()
        elif value > optimal_range[1]:
            status = "high"
            category = parameter.lower()
        else:
            status = "optimal"
            category = parameter.lower()
        
        # Get relevant documents from knowledge base
        if category in self.knowledge_base:
            relevant_docs.extend(self.knowledge_base[category])
        
        # Add recommendations if not optimal
        if status != "optimal":
            relevant_docs.extend(self.knowledge_base["recommendations"])
        
        return relevant_docs, status
    
    def generate_rag_recommendation(self, N, P, K, pH, moisture):
        """Generate RAG-based recommendations for soil parameters"""
        recommendations = []
        issues = []
        
        # Analyze each parameter
        params = {
            'Nitrogen (N)': (N, (20, 50)),
            'Phosphorus (P)': (P, (15, 40)),
            'Potassium (K)': (K, (30, 60)),
            'pH': (pH, (6.0, 7.5)),
            'Moisture': (moisture, (30, 70))
        }
        
        for param_name, (value, range_tuple) in params.items():
            docs, status = self.retrieve_relevant_knowledge(param_name, value, range_tuple)
            
            if status == "low":
                issues.append(f"{param_name} is LOW ({value}/{range_tuple[1]})")
                recommendations.append(docs[0] if docs else f"Increase {param_name}")
            elif status == "high":
                issues.append(f"{param_name} is HIGH ({value}/{range_tuple[0]})")
                recommendations.append(docs[0] if docs else f"Decrease {param_name}")
        
        return issues, recommendations

# ============================================

data = []
for ts in timestamps:
    N, P, K, pH, moisture = generate_sensor_data()
    fertile = is_fertile(N, P, K, pH, moisture)
    data.append([ts, N, P, K, pH, moisture, fertile])

df = pd.DataFrame(data, columns=['Timestamp', 'N', 'P', 'K', 'pH', 'Moisture', 'Fertile'])

# 3. Format the Timestamp for Display
# This keeps the underlying data as objects but makes the strings clean
df['Timestamp_Display'] = df['Timestamp'].dt.strftime('%b %d, %H:%M')

print(f"Total readings collected: {len(df)}")
print("\n=== SAMPLE SOIL READINGS ===")
print(df[['Timestamp_Display', 'N', 'P', 'K', 'pH', 'Moisture', 'Fertile']].head())

# ============================================
# MACHINE LEARNING MODEL TRAINING
# ============================================

# Use generated data for training
X = df[['N', 'P', 'K', 'pH', 'Moisture']]
y = df['Fertile']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train RandomForest model
print("\n=== TRAINING MACHINE LEARNING MODEL ===")
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Predictions
y_pred = model.predict(X_test)

# Evaluation
print("\nClassification Report:")
print(classification_report(y_test, y_pred))
print("\nConfusion Matrix:")
print(confusion_matrix(y_test, y_pred))

# Visualization: Feature Importance
plt.figure(figsize=(8,5))
sns.barplot(x=model.feature_importances_, y=X.columns)
plt.title("Feature Importance for Soil Fertility")
plt.tight_layout()
plt.savefig('feature_importance.png', dpi=100, bbox_inches='tight')
plt.close()

# Predict for all records
df['Predicted_Fertility'] = model.predict(X)
df['Predicted_Fertility_Label'] = df['Predicted_Fertility'].apply(lambda x: 'Fertile' if x == 1 else 'Not Fertile')

# ============================================
# RAG INTEGRATION WITH ML PREDICTIONS
# ============================================
print("\n=== GENERATING RAG-ENHANCED RECOMMENDATIONS ===\n")

# Initialize RAG system
rag_system = SoilFertilityRAG(SOIL_KNOWLEDGE_BASE)

# Generate recommendations for each reading
rag_issues = []
rag_recommendations = []

for idx, row in df.iterrows():
    issues, recommendations = rag_system.generate_rag_recommendation(
        row['N'], row['P'], row['K'], row['pH'], row['Moisture']
    )
    rag_issues.append('; '.join(issues) if issues else 'All parameters optimal')
    rag_recommendations.append('; '.join(recommendations[:2]) if recommendations else 'Continue current practices')

df['RAG_Issues'] = rag_issues
df['RAG_Recommendations'] = rag_recommendations

# Create final conclusion combining ML + RAG
def create_final_conclusion(ml_prediction, rag_issues):
    if ml_prediction == 1:
        if 'optimal' in rag_issues.lower():
            return 'FERTILE - Excellent condition'
        else:
            return 'FERTILE - Some adjustments recommended'
    else:
        return 'NOT FERTILE - Action needed'

df['Final_Assessment'] = df.apply(
    lambda row: create_final_conclusion(row['Predicted_Fertility'], row['RAG_Issues']),
    axis=1
)

# ============================================

# Display detailed results with RAG recommendations
print("\n=== DETAILED SOIL FERTILITY ANALYSIS WITH RAG RECOMMENDATIONS ===\n")
result_cols = ['Timestamp_Display', 'N', 'P', 'K', 'pH', 'Moisture', 
               'Predicted_Fertility_Label', 'RAG_Issues', 'RAG_Recommendations', 'Final_Assessment']
print(df[result_cols].head(10).to_string(index=False))

# Save comprehensive results
dataset_folder = 'dataset'
if not os.path.exists(dataset_folder):
    os.makedirs(dataset_folder)

df.to_csv(os.path.join(dataset_folder, "soil_fertility_results.csv"), index=False)
print(f"\nâœ“ Results saved to 'dataset/soil_fertility_results.csv'")

# Show summary statistics
print("\n=== SUMMARY STATISTICS ===")
print(f"Total readings: {len(df)}")
print(f"Fertile readings (ML): {(df['Predicted_Fertility'] == 1).sum()}")
print(f"Not Fertile readings (ML): {(df['Predicted_Fertility'] == 0).sum()}")
print(f"Readings with optimal parameters: {(df['RAG_Issues'] == 'All parameters optimal').sum()}")

# ============================================
# VISUALIZATIONS
# ============================================

# 1. Visualization: Nutrients Over Time
print("\n=== GENERATING VISUALIZATIONS ===")
df_subset = df.head(15).copy()
df_subset['Timestamp'] = pd.to_datetime(df_subset['Timestamp'])
df_subset['Time_Label'] = df_subset['Timestamp'].dt.strftime('%H:%M')

sns.set_theme(style="whitegrid")
fig, ax1 = plt.subplots(figsize=(14, 6))

# Plot N, P, K on the primary Y-axis
sns.lineplot(data=df_subset, x='Time_Label', y='N', marker='o', label='Nitrogen (N)', ax=ax1)
sns.lineplot(data=df_subset, x='Time_Label', y='P', marker='s', label='Phosphorus (P)', ax=ax1)
sns.lineplot(data=df_subset, x='Time_Label', y='K', marker='^', label='Potassium (K)', ax=ax1)

ax1.set_ylabel('Nutrient Value (mg/kg)', fontsize=11)
ax1.set_xlabel('Time (HH:MM)', fontsize=11)
ax1.set_title('Soil Nutrients (NPK) Over Time - Initial Readings', fontweight='bold', fontsize=13)
ax1.axhline(y=20, color='r', linestyle='--', alpha=0.3, label='N Min')
ax1.axhline(y=30, color='g', linestyle='--', alpha=0.3, label='K Min')

# 2. Use a second Y-axis for pH
ax2 = ax1.twinx()
sns.lineplot(data=df_subset, x='Time_Label', y='pH', color='red', marker='X', label='pH Level', ax=ax2)
ax2.set_ylabel('pH Level', color='red', fontsize=11)
ax2.set_ylim(5, 8)

# Combine legends
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left', fontsize=9)

plt.tight_layout()
plt.savefig('soil_nutrients_over_time.png', dpi=100, bbox_inches='tight')
plt.close()

# 2. Visualization: Fertility Assessment Distribution
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# ML Predictions
fertility_counts = df['Predicted_Fertility_Label'].value_counts()
axes[0].bar(fertility_counts.index, fertility_counts.values, color=['#fe6b6b', '#51cf66'])
axes[0].set_title('ML Predictions: Soil Fertility Distribution', fontweight='bold')
axes[0].set_ylabel('Number of Readings')
axes[0].grid(axis='y', alpha=0.3)

# Final Assessment
assessment_counts = df['Final_Assessment'].value_counts()
colors_map = {'FERTILE - Excellent condition': '#51cf66', 
              'FERTILE - Some adjustments recommended': '#ffd43b',
              'NOT FERTILE - Action needed': '#fe6b6b'}
colors = [colors_map.get(val, '#999') for val in assessment_counts.index]
axes[1].bar(range(len(assessment_counts)), assessment_counts.values, color=colors)
axes[1].set_xticks(range(len(assessment_counts)))
axes[1].set_xticklabels(assessment_counts.index, rotation=15, ha='right', fontsize=9)
axes[1].set_title('Final Assessment (ML + RAG Combined)', fontweight='bold')
axes[1].set_ylabel('Number of Readings')
axes[1].grid(axis='y', alpha=0.3)

plt.tight_layout()
plt.savefig('fertility_assessment_distribution.png', dpi=100, bbox_inches='tight')
plt.close()

# 3. Visualization: Parameter Adequacy Heatmap
print("\nVisualization saved successfully!")
